# 621 任务调度器

## 题目描述

给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。

然而，两个相同种类的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。

你需要计算完成所有任务所需要的最短时间。

输入：

tasks = ["A","A","A","B","B","B"], n = 2

输出：8

解释：A -> B -> (待命) -> A -> B -> (待命) -> A -> B.
在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。

提示：

任务的总个数为 [1, 10000]。
n 的取值范围为 [0, 100]。

## 思路

统计词频，按照频率最高的词来计算：举个例子
假设数组["A", "A", "A", "B", "B","C"], n=2, A 的频率最高，两个A之间必须要间隔2个任务，才能满足题意。间隔大于2必然不是最短的\
时间。因此执行的顺序为： A-->X-->X-->A-->X-->X-->A, 这里 **X 表示除了 A 以外的其它字母， 或是待机状态，不用管是什么，反正是用来填充的**,count-1 个A， 每个A有 n个X。那么类似上面 A-->X-->X的结构总长度为： (count[25]-1)\*(n+1),加上最后一个A即可。\
实际情况是，最高频率的词可能存在多个，比如["A", "A", "A", "B", "B", “B”， "C"]，此时最后会剩下 A,B, 所以最后要加上频率最高的不同任务的个数maxcount.\
公式算出的结果可能会比数组长度小，比如 ["A", "A" ,"B" , "B"]，n=0. 此时要取数组长度。

## 代码

```C++
class Solution {
public:
    int leastInterval(vector<char>& tasks, int n) {
        vector<int> store(26,0);
        for(int i=0;i<tasks.size();i++)
        {
            store[tasks[i]-'A']++;
        }
        sort(store.begin(),store.end());
        int maxcount=0;
        for(int i=25;i>=0;i--)
        {
            if(store[i]!=store[25])
                break;
            maxcount++;
        }
        int res=0;
        if((store[25]-1)*(n+1)+maxcount>tasks.size())
            res=(store[25]-1)*(n+1)+maxcount;
        else
            res=tasks.size();
        
        return res;
    }
};
```


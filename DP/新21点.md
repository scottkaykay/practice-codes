## 新21点



## 思路

规则描述：

· 她可以从牌面为 [1,W] 的牌中选择任意一张，这张牌是可以无限重复的，也就是说无论她取多少次，每次取到 2（假如 2 在 [1,W] 范围内）的概率都是 1/W;\
· 如果她手上牌的总额小于 K，她就会抽牌，大于等于 K 时，就停止抽牌;\
· 停止抽牌后，她的牌面小于等于 N 时，她就获胜了，求她获胜的概率。

假设 dp[x] 为她手上牌面为x时，能获胜的概率，那么这个概率应该是：

dp[x]=1/w * (dp[x+1]+dp[x+2]+dp[x+3]...+dp[x+w])

因为抽取的牌面机会都是均等的，她能抽取的面值在 [1,W] 之间，所以将概率之和平均一下就是 dp[x] 的概率。

x代表爱丽丝手上的牌面值，dp[x]代表爱丽丝手上持有的牌面值为x时，她获胜的概率（游戏结束时她所持牌面值小于等于N的概率）。
这个概率是怎么来的？x分2种情况:

· 当x>=K时，爱丽丝会停止抽牌，这个时候游戏已经结束了，她是赢是输也已经确定了，所以此时赢的概率要么1，要么0
·当x<K时，爱丽丝会继续抽牌，抽牌是有概率的，所以她是赢是输也有概率。
她能抽到的牌面值在 [1,W] 之间，所以抽完后她的牌面在[x+1,x+w]之间，因为每张牌机率均等，所以抽完后牌面在[x+1,x+w]之间的每个面值概率都是相等的，而假如我们已知当牌面是[x+1,x+w]的胜率(即dp[x+1]...dp[x+w]的值)，那么可以推导：
dp[x]=1/w * dp[x+1]+ 1/w * dp[x+2] + 1/w * dp[x+3]...+ 1/w * dp[x+w]
这个实际上就是动态规划的状态转移方程，不过本例是反着来转移的。

x 最多能到 K-1，因为当大于等于 K 时，爱丽丝会停止抽牌，所以当游戏结束时，即爱丽丝停止抽牌时，她可能达到的最大牌面是 K+W-1，而一开始她的牌面是 0，所以我们用一个长度为 K+W 的 dp 数组来保存她在所有面值下的胜率。
最后 dp[0]，也就是最开始爱丽丝还没有抽牌，她的牌面为 0 时的胜率，这个就是我们的答案。

填格子：

0    1     2     3    ...    K-1  |  K     ...     K+W-1

将这个格子分成了 2 部分 [0,K-1] 和 [K,K+W-1]，区别就是 [0,K-1] 爱丽丝可以抽牌，[K,K+W-1] 时不能抽牌，那么不能抽牌时她获胜的概率是多少呢，
此时已不能抽牌，要么赢要么输，很显然牌面小于等于N时，概率就是 1，大于 N 概率就是 0，所以先直接填满右边的格子。

再填左边的部分：根据上面的公式，概率之和除以w

## 代码

```Python
class Solution:
    def new21Game(self,N:int,K:int,W:int) -> float:
        dp=[None]*(K+W)
        s=0
        for i in range(K,K+W):
            if i<=N:
                dp[i]=1
            else:
                dp[i]=0
            s+=dp[i]
        for i in range(K-1,-1,-1):
            dp[i]=s/w
            s=s-dp[i+W]+dp[i]
        return dp[0]
        
```

```C++
int new24game(int N,int K,int W)
{
    vector<int> dp(K+W,0);
    int s=0;
    for(int i=K;i<K+W;++i)
    {
        if(i<=N)
            dp[i]=1;
        else
            dp[i]=0;
        s+=dp[i];
    }
    for(int i=K-1;i>=0;--i)
    {
        dp[i]=s/W;
        s=s-dp[i+W]+dp[i];
    }
    return dp[0];
}

```

## 正则字符串

请实现一个函数用来匹配包含'. '和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）。在本题中，\
匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但与"aa.a"和"ab*a"均不匹配。

输入:

s = "aa"\
p = "a"\
输出: false\
解释: "a" 无法匹配 "aa" 整个字符串。

输入:\
s = "aa"\
p = "a*"\
输出: true\
解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。

输入:\
s = "ab"\
p = ".*"\
输出: true\
解释: ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。

输入:\
s = "aab"\
p = "c*a*b"\
输出: true\
解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。

输入:\
s = "mississippi"\
p = "mis*is*p*."\
输出: false

## 思路

主串为A,长度为n, 模式串为B, 长度为m . 从最后一个字符开始看，分别有三种情况：

1. B的最后一个字符是正常字符, 观察A[n-1] 是否等于 B[m-1], 如果相等，二者同时前移一位比较，否则直接返回false

2. B的最后一个字符是'.' , 它能代表任何一个字符，A,B都前移一位继续比较

3. B的最后一个字符为'*',观察A[n-1]和 B[m-2]是否匹配：

 i. 不匹配：观察A[n-1] ,B[m-3]是否匹配
 
 ii. 匹配，A前移一位，B不动，因为B[m-1]为'*',表示前面的元素可以多次出现
 
 f[i][j] 表示A的前i个和B的前j个能否匹配，针对情况1,2： f[i][j]=f[i-1][j-1]
 
 第三种情况：
 
 i. f[i][j]=f[i][j-2]\
 ii.  f[i][j]=f[i-1][j]
 
 初始条件：
 
 f[i][0]=false  f[0][0]=true
 
 ## 代码
 
 ```C++
 bool ismatch(string A,string B)
 {
    int n=A.size();
    int m=B.size();
    vector<vector<bool>> dp(n+1,vector<bool>(m+1,false));
    dp[0][0]=true;
    for(int i=0;i<=n;i++)
    {
        for(int j=0;j<=m;j++)
        {
            if(j==0)
                dp[i][j]=i==0;
            else
            {
                if(B[j-1]!='*')
                {
                    if(i>0 && (A[i-1]==B[j-1] || B[j-1]=='.'))
                        f[i][j]=f[i-1][j-1];
                  
                }
                else
                {
                    //不看最后2位，直接跳过
                    if(j>=2)
                        f[i][j]=f[i][j] | f[i][j-2];  //这里使用|号说明在第三种情况中，不看最后两位和看最后两位，只要有一种能和A匹配上就行
                    //看最后两位
                    if(i>=1 && j>=2 && (A[i-1]==B[j-2] || B[j-2]=='.'))
                        f[i][j]=f[i][j] | f[i-1][j];
                }
            }
        }
    }
    return f[n][m];
 }
 ```
 
 
